{
  "verdict": "FAIL",
  "findings": [
    {
      "ruleId": "SQL001_TEMPLATE_TO_QUERY",
      "kind": "FAIL",
      "severity": "CRITICAL",
      "status": "NEW",
      "title": "SQL query built with string interpolation or concatenation",
      "description": "A SQL query string is constructed via template interpolation, string concatenation, or format strings, then passed into a query execution API.",
      "risk": "Interpolating or concatenating user input into SQL enables SQL injection, allowing attackers to read, modify, or delete database data.",
      "confidenceRationale": "Interpolation or concatenation inside a direct query execution call is a deterministic indicator of unsafe query construction.",
      "recommendation": "Use parameterized queries or prepared statements in every language: ? placeholders (Go/Java/PHP), @param (C#), bind parameters (Rails ActiveRecord).",
      "file": "stress_fixtures.js",
      "line": 62,
      "snippet": "const user = await db.query(`SELECT * FROM users WHERE id = ${id}`);"
    },
    {
      "ruleId": "CMD001_UNSAFE_COMMAND_EXEC",
      "kind": "FAIL",
      "severity": "CRITICAL",
      "status": "NEW",
      "title": "Direct user input in command execution",
      "description": "User-supplied input is passed directly to a command execution sink across JavaScript, Java, Go, C#, Ruby, or PHP.",
      "risk": "Allows Remote Code Execution (RCE). Attackers can execute arbitrary shell commands with the privileges of the application process.",
      "confidenceRationale": "A user-input source and a shell execution sink on the same line is a near-certain indicator of command injection.",
      "recommendation": "Never pass user input to shell commands. Use allowlisted argument arrays and avoid spawning shells. Prefer native libraries over shell commands.",
      "file": "stress_fixtures.js",
      "line": 10,
      "snippet": "require('child_process').exec('rm -rf /data/' + req.query.id);"
    },
    {
      "ruleId": "SEC008_SSRF_VULNERABILITY",
      "kind": "FAIL",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Potential SSRF via direct user input in HTTP request",
      "description": "A user-supplied value is passed directly to a network request sink without validation.",
      "risk": "Enables Server-Side Request Forgery (SSRF), allowing attackers to reach internal infrastructure, cloud metadata services (169.254.169.254), or internal APIs on behalf of the server.",
      "confidenceRationale": "A user-input source and an HTTP client sink on the same line is a near-certain SSRF indicator across all languages.",
      "recommendation": "Never allow users to specify arbitrary URLs. Enforce an allowlist of permitted domains/schemes and validate all URLs server-side before making requests.",
      "file": "stress_fixtures.js",
      "line": 22,
      "snippet": "const response = await fetch(req.body.targetUrl);"
    },
    {
      "ruleId": "MASS001_MASS_ASSIGNMENT",
      "kind": "FAIL",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Mass Assignment (Insecure Object Hydration)",
      "description": "Request data (req.body or params) is assigned directly to an object or database model without filtering which properties are allowed.",
      "risk": "Attackers can supply unexpected properties (e.g., {'role': 'admin', 'isAdmin': true}) to escalate privileges or bypass business logic during object creation or updates.",
      "confidenceRationale": "Directly assigning request objects to models without a permit/allowlist filter is a classic high-risk pattern.",
      "recommendation": "Use allowlisting to restrict which properties can be updated from user input. In Rails, use Strong Parameters (`params.require(...).permit(...)`). In Node, use an explicit mapping or a library like `lodash.pick`.",
      "file": "stress_fixtures.js",
      "line": 48,
      "snippet": "Object.assign(baseConfig, req.body);"
    },
    {
      "ruleId": "I302_SQL_TEMPLATE_LITERAL",
      "kind": "WARN",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Possible SQL injection risk (template literal)",
      "description": "SQL appears to be constructed using a template literal with interpolation.",
      "risk": "If untrusted input is interpolated, this may enable SQL injection.",
      "confidenceRationale": "Interpolation is detectable, but context (trusted vs untrusted input) cannot be proven from diff-only scanning.",
      "recommendation": "Use parameterized queries or library-supported placeholders instead of interpolating variables into SQL.",
      "file": "stress_fixtures.js",
      "line": 62,
      "snippet": "const user = await db.query(`SELECT * FROM users WHERE id = ${id}`);"
    },
    {
      "ruleId": "I312_SHELL_COMMAND_CONCAT",
      "kind": "WARN",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Possible command injection risk (string concatenation)",
      "description": "A shell command appears to be constructed using string concatenation.",
      "risk": "If user input influences the concatenated command, this may enable command injection and remote code execution.",
      "confidenceRationale": "Concatenation is detectable, but input provenance cannot be proven from diff-only scanning.",
      "recommendation": "Avoid shell execution when possible. Use safe APIs and pass arguments as arrays rather than concatenated strings.",
      "file": "stress_fixtures.js",
      "line": 10,
      "snippet": "require('child_process').exec('rm -rf /data/' + req.query.id);"
    },
    {
      "ruleId": "I313_SHELL_COMMAND_FROM_REQ",
      "kind": "WARN",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Command execution may use request input",
      "description": "Command execution appears to directly reference request input.",
      "risk": "Direct use of request input in command execution can lead to command injection and remote code execution.",
      "confidenceRationale": "The sink and input reference are both present in the same expression, but sanitization may still exist elsewhere.",
      "recommendation": "Do not pass untrusted input to shell commands. Use strict allowlists and argument arrays, or remove shell usage.",
      "file": "stress_fixtures.js",
      "line": 10,
      "snippet": "require('child_process').exec('rm -rf /data/' + req.query.id);"
    },
    {
      "ruleId": "P1316_SELECT_STAR_USERS_IN_HANDLER",
      "kind": "WARN",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Query selects all columns from users",
      "description": "Code introduces `SELECT * FROM users` which commonly includes sensitive columns.",
      "risk": "Selecting all columns increases the chance of leaking password hashes, tokens, internal flags, and PII to the application layer and responses.",
      "confidenceRationale": "The SQL pattern is explicit; whether the result is returned to clients depends on the handler.",
      "recommendation": "Select explicit allowlisted columns for user queries and separate internal columns from public profile data.",
      "file": "stress_fixtures.js",
      "line": 62,
      "snippet": "const user = await db.query(`SELECT * FROM users WHERE id = ${id}`);"
    },
    {
      "ruleId": "P1316_SELECT_STAR_USERS_IN_HANDLER",
      "kind": "WARN",
      "severity": "HIGH",
      "status": "NEW",
      "title": "Query selects all columns from users",
      "description": "Code introduces `SELECT * FROM users` which commonly includes sensitive columns.",
      "risk": "Selecting all columns increases the chance of leaking password hashes, tokens, internal flags, and PII to the application layer and responses.",
      "confidenceRationale": "The SQL pattern is explicit; whether the result is returned to clients depends on the handler.",
      "recommendation": "Select explicit allowlisted columns for user queries and separate internal columns from public profile data.",
      "file": "stress_fixtures.js",
      "line": 67,
      "snippet": "const user = await db.query('SELECT * FROM users WHERE id = ?', [id]);"
    },
    {
      "ruleId": "A222_IDOR_STYLE_PARAM",
      "kind": "WARN",
      "severity": "MEDIUM",
      "status": "NEW",
      "title": "User-controlled identifier used",
      "description": "A user-controlled identifier parameter was introduced.",
      "risk": "If authorization checks are missing, this can lead to insecure direct object reference (IDOR) issues.",
      "confidenceRationale": "Identifiers are common and often safe; static analysis cannot confirm authorization enforcement.",
      "recommendation": "Ensure access checks validate ownership/tenant membership for any resource referenced by user-controlled IDs.",
      "file": "stress_fixtures.js",
      "line": 10,
      "snippet": "require('child_process').exec('rm -rf /data/' + req.query.id);"
    },
    {
      "ruleId": "I309_GRAPHQL_INJECTION_RISK",
      "kind": "WARN",
      "severity": "MEDIUM",
      "status": "NEW",
      "title": "GraphQL query construction may be risky",
      "description": "A GraphQL query appears to be constructed dynamically as a string.",
      "risk": "Dynamic query construction can increase risk of injection-like issues or authorization bypass depending on server logic.",
      "confidenceRationale": "GraphQL systems vary widely; dynamic strings are not always unsafe but warrant review.",
      "recommendation": "Prefer persisted queries or structured query building. Ensure variables and authorization checks are enforced server-side.",
      "file": "stress_fixtures.js",
      "line": 62,
      "snippet": "const user = await db.query(`SELECT * FROM users WHERE id = ${id}`);"
    }
  ]
}